usethis::use_mit_license()
roxygen2::roxygenise()
library(hiperglm)
test <- hiperglm::hiper_glm(0,1)
View(test)
print(test)
roxygen2::roxygenise()
library(hiperglm)
test <- hiperglm::hiper_glm(0,1)
print(test)
usethis::use_testthat()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
option = list(mle_solver = 'BFGS')
option$mle_solver
devtools::test()
roxygen2::roxygenise()
library(hiperglm)
roxygen2::roxygenise()
library(hiperglm)
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
option=list()
option[['mle_solver']]
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
roxygen2::roxygenise()
devtools::test()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::test()
devtools::test()
are_all_close <- function(v, w, abs_tol = 1e-6, rel_tol = 1e-6) {
abs_diff <- abs(v - w)
are_all_within_atol <- all(abs_diff < abs_tol)
are_all_within_rtol <- all(abs_diff < rel_tol * pmax(abs(v), abs(w)))
return(are_all_within_atol && are_all_within_rtol)
}
simulate_data <- function(
n_obs, n_pred, model = "linear", intercept = NULL,
coef_true = NULL, design = NULL, seed = NULL, signal_to_noise = 0.1
) {
if (!is.null(seed)) {
set.seed(seed)
}
if (is.null(coef_true)) {
coef_true <- rnorm(n_pred, sd = 1 / sqrt(n_pred))
}
if (is.null(design)) {
design <- matrix(rnorm(n_obs * n_pred), nrow = n_obs, ncol = n_pred)
}
if (!is.null(intercept)) {
if (!is.numeric(intercept)) {
stop("The intercept argument must be numeric.")
}
coef_true <- c(intercept, coef_true)
design <- cbind(rep(1, n_obs), design)
}
expected_mean <- as.vector(design %*% coef_true)
noise_magnitude <- sqrt(var(expected_mean) / signal_to_noise^2)
noise <- noise_magnitude * rnorm(n_obs)
outcome <- expected_mean + noise
return(list(design = design, outcome = outcome, coef_true = coef_true))
}
n_obs <- 32; n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = 'linear', seed = 1918)
design <- data$design; outcome <- data$outcome
design
dim(design)
beta_ini = rep(0,4)
design %*% beta_ini
roxygen2::roxygenise()
devtools::test()
devtools::test()
MLE_peudo.inverse <- function(design,outcome){
return(solve(t(design)%*%design,t(design)%*%outcome))
}
linear.loglik <- function(MLE){
loglik = -length(outcome)/2*log(noise_var)-sum((outcome - design%*%MLE)^2)/2/noise_var
loglik
}
linear.gradient <- function(MLE){
gradient = -(t(design) %*% design %*% MLE - t(design)%*% outcome)/noise_var
gradient
}
linear.BFGS<-function(design,outcome,noise_var = 1){
initial = rep(0,ncol(design))
MLE = stats::optim(initial,linear.loglik,linear.gradient,method = 'BFGS')
return(MLE)
}
# TODO: find MLE.
MLE = as.vector(MLE_peudo.inverse(design,outcome))
MLE
hglm_out <- list(coef=MLE)
MLE_peudo.inverse <- function(design,outcome){
return(solve(t(design)%*%design,t(design)%*%outcome))
}
linear.loglik <- function(MLE){
loglik = -length(outcome)/2*log(noise_var)-sum((outcome - design%*%MLE)^2)/2/noise_var
loglik
}
linear.gradient <- function(MLE){
gradient = -(t(design) %*% design %*% MLE - t(design)%*% outcome)/noise_var
gradient
}
linear.BFGS<-function(design,outcome,noise_var = 1){
initial = rep(0,ncol(design))
MLE = stats::optim(initial,linear.loglik,linear.gradient,method = 'BFGS')
return(MLE)
}
MLE = linear.BFGS(design,outcome,noise_var = 1)
MLE_peudo.inverse <- function(design,outcome){
return(solve(t(design)%*%design,t(design)%*%outcome))
}
linear.loglik <- function(MLE,design,outcome,noise_var = 1){
loglik = -length(outcome)/2*log(noise_var)-sum((outcome - design%*%MLE)^2)/2/noise_var
loglik
}
linear.gradient <- function(MLE,design,outcome,noise_var = 1){
gradient = -(t(design) %*% design %*% MLE - t(design)%*% outcome)/noise_var
gradient
}
linear.BFGS<-function(design,outcome,noise_var = 1){
initial = rep(0,ncol(design))
MLE = stats::optim(initial,linear.loglik,linear.gradient,method = 'BFGS')
return(MLE)
}
MLE = linear.BFGS(design,outcome,noise_var = 1)
MLE_peudo.inverse <- function(design,outcome){
return(solve(t(design)%*%design,t(design)%*%outcome))
}
linear.loglik <- function(MLE,design=design,outcome=outcome,noise_var = 1){
loglik = -length(outcome)/2*log(noise_var)-sum((outcome - design%*%MLE)^2)/2/noise_var
loglik
}
linear.gradient <- function(MLE,design=design,outcome=outcome,noise_var = 1){
gradient = -(t(design) %*% design %*% MLE - t(design)%*% outcome)/noise_var
gradient
}
linear.BFGS<-function(design,outcome,noise_var = 1){
initial = rep(0,ncol(design))
MLE = stats::optim(initial,linear.loglik,linear.gradient,method = 'BFGS')
return(MLE)
}
MLE = linear.BFGS(design,outcome,noise_var = 1)
linear.BFGS<-function(design,outcome,noise_var = 1){
initial = rep(0,ncol(design))
MLE = stats::optim(initial,linear.loglik,linear.gradient,
design=design,outcome=outcome,noise_var = 1,
method = 'BFGS')
return(MLE)
}
MLE = linear.BFGS(design,outcome,noise_var = 1)
MLE$par
MLE$value
MLE$message
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
roxygen2::roxygenise()
devtools::test()
devtools::test()
devtools::test()
option=list()
devtools::test()
devtools::test()
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
option = list(mle_solver = 'BFGS')
option$mle_solver
option$mle_solver=="BFGS"
roxygen2::roxygenise()
library(hiperglm)
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
roxygen2::roxygenise()
library(hiperglm)
